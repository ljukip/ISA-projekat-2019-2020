{"ast":null,"code":"/*\r\n * Copyright 2017-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\r\n * the License. A copy of the License is located at\r\n *\r\n *     http://aws.amazon.com/apache2.0/\r\n *\r\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\r\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\r\n * and limitations under the License.\r\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar DoubleLinkedNode =\n/** @class */\nfunction () {\n  function DoubleLinkedNode(keyVal) {\n    this.key = keyVal ? keyVal : '';\n    this.prevNode = null;\n    this.nextNode = null;\n  }\n\n  return DoubleLinkedNode;\n}();\n/**\r\n * double linked list plus a hash table inside\r\n * each key in the cache stored as a node in the list\r\n * recently visited node will be rotated to the head\r\n * so the Last Recently Visited node will be at the tail\r\n *\r\n * @member head - dummy head of the linked list\r\n * @member tail - dummy tail of the linked list\r\n * @member hashtable - the hashtable which maps cache key to list node\r\n * @member length - length of the list\r\n */\n\n\nvar CacheList =\n/** @class */\nfunction () {\n  /**\r\n   * initialization\r\n   */\n  function CacheList() {\n    this.head = new DoubleLinkedNode();\n    this.tail = new DoubleLinkedNode();\n    this.hashtable = {};\n    this.length = 0;\n    this.head.nextNode = this.tail;\n    this.tail.prevNode = this.head;\n  }\n  /**\r\n   * insert node to the head of the list\r\n   *\r\n   * @param node\r\n   */\n\n\n  CacheList.prototype.insertNodeToHead = function (node) {\n    var tmp = this.head.nextNode;\n    this.head.nextNode = node;\n    node.nextNode = tmp;\n    node.prevNode = this.head;\n    tmp.prevNode = node;\n    this.length = this.length + 1;\n  };\n  /**\r\n   * remove node\r\n   *\r\n   * @param node\r\n   */\n\n\n  CacheList.prototype.removeNode = function (node) {\n    node.prevNode.nextNode = node.nextNode;\n    node.nextNode.prevNode = node.prevNode;\n    node.prevNode = null;\n    node.nextNode = null;\n    this.length = this.length - 1;\n  };\n  /**\r\n   * @return true if list is empty\r\n   */\n\n\n  CacheList.prototype.isEmpty = function () {\n    return this.length === 0;\n  };\n  /**\r\n   * refresh node so it is rotated to the head\r\n   *\r\n   * @param key - key of the node\r\n   */\n\n\n  CacheList.prototype.refresh = function (key) {\n    var node = this.hashtable[key];\n    this.removeNode(node);\n    this.insertNodeToHead(node);\n  };\n  /**\r\n   * insert new node to the head and add it in the hashtable\r\n   *\r\n   * @param key - the key of the node\r\n   */\n\n\n  CacheList.prototype.insertItem = function (key) {\n    var node = new DoubleLinkedNode(key);\n    this.hashtable[key] = node;\n    this.insertNodeToHead(node);\n  };\n  /**\r\n   * @return the LAST Recently Visited key\r\n   */\n\n\n  CacheList.prototype.getLastItem = function () {\n    return this.tail.prevNode.key;\n  };\n  /**\r\n   * remove the cache key from the list and hashtable\r\n   * @param key - the key of the node\r\n   */\n\n\n  CacheList.prototype.removeItem = function (key) {\n    var removedItem = this.hashtable[key];\n    this.removeNode(removedItem);\n    delete this.hashtable[key];\n  };\n  /**\r\n   * @return length of the list\r\n   */\n\n\n  CacheList.prototype.getSize = function () {\n    return this.length;\n  };\n  /**\r\n   * @return true if the key is in the hashtable\r\n   * @param key\r\n   */\n\n\n  CacheList.prototype.containsKey = function (key) {\n    return key in this.hashtable;\n  };\n  /**\r\n   * clean up the list and hashtable\r\n   */\n\n\n  CacheList.prototype.clearList = function () {\n    var e_1, _a;\n\n    try {\n      for (var _b = __values(Object.keys(this.hashtable)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var key = _c.value;\n\n        if (this.hashtable.hasOwnProperty(key)) {\n          delete this.hashtable[key];\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    this.head.nextNode = this.tail;\n    this.tail.prevNode = this.head;\n    this.length = 0;\n  };\n  /**\r\n   * @return all keys in the hashtable\r\n   */\n\n\n  CacheList.prototype.getKeys = function () {\n    return Object.keys(this.hashtable);\n  };\n  /**\r\n   * mainly for test\r\n   *\r\n   * @param key\r\n   * @return true if key is the head node\r\n   */\n\n\n  CacheList.prototype.isHeadNode = function (key) {\n    var node = this.hashtable[key];\n    return node.prevNode === this.head;\n  };\n  /**\r\n   * mainly for test\r\n   *\r\n   * @param key\r\n   * @return true if key is the tail node\r\n   */\n\n\n  CacheList.prototype.isTailNode = function (key) {\n    var node = this.hashtable[key];\n    return node.nextNode === this.tail;\n  };\n\n  return CacheList;\n}();\n\nexport default CacheList;","map":{"version":3,"sources":["../../src/Utils/CacheList.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAaA,IAAA,gBAAA;AAAA;AAAA,YAAA;AAKC,WAAA,gBAAA,CAAY,MAAZ,EAA2B;AAC1B,SAAK,GAAL,GAAW,MAAM,GAAG,MAAH,GAAY,EAA7B;AACA,SAAK,QAAL,GAAgB,IAAhB;AACA,SAAK,QAAL,GAAgB,IAAhB;AACA;;AACF,SAAA,gBAAA;AAAC,CAVD,EAAA;AAYA;;;;;;;;;;;;;AAWA,IAAA,SAAA;AAAA;AAAA,YAAA;AAMC;;;AAGA,WAAA,SAAA,GAAA;AACC,SAAK,IAAL,GAAY,IAAI,gBAAJ,EAAZ;AACA,SAAK,IAAL,GAAY,IAAI,gBAAJ,EAAZ;AACA,SAAK,SAAL,GAAiB,EAAjB;AACA,SAAK,MAAL,GAAc,CAAd;AAEA,SAAK,IAAL,CAAU,QAAV,GAAqB,KAAK,IAA1B;AACA,SAAK,IAAL,CAAU,QAAV,GAAqB,KAAK,IAA1B;AACA;AAED;;;;;;;AAKQ,EAAA,SAAA,CAAA,SAAA,CAAA,gBAAA,GAAR,UAAyB,IAAzB,EAA+C;AAC9C,QAAM,GAAG,GAAqB,KAAK,IAAL,CAAU,QAAxC;AACA,SAAK,IAAL,CAAU,QAAV,GAAqB,IAArB;AACA,IAAA,IAAI,CAAC,QAAL,GAAgB,GAAhB;AACA,IAAA,IAAI,CAAC,QAAL,GAAgB,KAAK,IAArB;AACA,IAAA,GAAG,CAAC,QAAJ,GAAe,IAAf;AAEA,SAAK,MAAL,GAAc,KAAK,MAAL,GAAc,CAA5B;AACA,GARO;AAUR;;;;;;;AAKQ,EAAA,SAAA,CAAA,SAAA,CAAA,UAAA,GAAR,UAAmB,IAAnB,EAAyC;AACxC,IAAA,IAAI,CAAC,QAAL,CAAc,QAAd,GAAyB,IAAI,CAAC,QAA9B;AACA,IAAA,IAAI,CAAC,QAAL,CAAc,QAAd,GAAyB,IAAI,CAAC,QAA9B;AAEA,IAAA,IAAI,CAAC,QAAL,GAAgB,IAAhB;AACA,IAAA,IAAI,CAAC,QAAL,GAAgB,IAAhB;AAEA,SAAK,MAAL,GAAc,KAAK,MAAL,GAAc,CAA5B;AACA,GARO;AAUR;;;;;AAGO,EAAA,SAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACC,WAAO,KAAK,MAAL,KAAgB,CAAvB;AACA,GAFM;AAIP;;;;;;;AAKO,EAAA,SAAA,CAAA,SAAA,CAAA,OAAA,GAAP,UAAe,GAAf,EAA0B;AACzB,QAAM,IAAI,GAAqB,KAAK,SAAL,CAAe,GAAf,CAA/B;AACA,SAAK,UAAL,CAAgB,IAAhB;AACA,SAAK,gBAAL,CAAsB,IAAtB;AACA,GAJM;AAMP;;;;;;;AAKO,EAAA,SAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,GAAlB,EAA6B;AAC5B,QAAM,IAAI,GAAqB,IAAI,gBAAJ,CAAqB,GAArB,CAA/B;AACA,SAAK,SAAL,CAAe,GAAf,IAAsB,IAAtB;AACA,SAAK,gBAAL,CAAsB,IAAtB;AACA,GAJM;AAMP;;;;;AAGO,EAAA,SAAA,CAAA,SAAA,CAAA,WAAA,GAAP,YAAA;AACC,WAAO,KAAK,IAAL,CAAU,QAAV,CAAmB,GAA1B;AACA,GAFM;AAIP;;;;;;AAIO,EAAA,SAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,GAAlB,EAA6B;AAC5B,QAAM,WAAW,GAAqB,KAAK,SAAL,CAAe,GAAf,CAAtC;AACA,SAAK,UAAL,CAAgB,WAAhB;AACA,WAAO,KAAK,SAAL,CAAe,GAAf,CAAP;AACA,GAJM;AAMP;;;;;AAGO,EAAA,SAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACC,WAAO,KAAK,MAAZ;AACA,GAFM;AAIP;;;;;;AAIO,EAAA,SAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,GAAnB,EAA8B;AAC7B,WAAO,GAAG,IAAI,KAAK,SAAnB;AACA,GAFM;AAIP;;;;;AAGO,EAAA,SAAA,CAAA,SAAA,CAAA,SAAA,GAAP,YAAA;;;;AACC,WAAkB,IAAA,EAAA,GAAA,QAAA,CAAA,MAAM,CAAC,IAAP,CAAY,KAAK,SAAjB,CAAA,CAAA,EAA2B,EAAA,GAAA,EAAA,CAAA,IAAA,EAA7C,EAA6C,CAAA,EAAA,CAAA,IAA7C,EAA6C,EAAA,GAAA,EAAA,CAAA,IAAA,EAA7C,EAA+C;AAA1C,YAAM,GAAG,GAAA,EAAA,CAAA,KAAT;;AACJ,YAAI,KAAK,SAAL,CAAe,cAAf,CAA8B,GAA9B,CAAJ,EAAwC;AACvC,iBAAO,KAAK,SAAL,CAAe,GAAf,CAAP;AACA;AACD;;;;;;;;;;;;;AACD,SAAK,IAAL,CAAU,QAAV,GAAqB,KAAK,IAA1B;AACA,SAAK,IAAL,CAAU,QAAV,GAAqB,KAAK,IAA1B;AACA,SAAK,MAAL,GAAc,CAAd;AACA,GATM;AAWP;;;;;AAGO,EAAA,SAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACC,WAAO,MAAM,CAAC,IAAP,CAAY,KAAK,SAAjB,CAAP;AACA,GAFM;AAIP;;;;;;;;AAMO,EAAA,SAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,GAAlB,EAA6B;AAC5B,QAAM,IAAI,GAAG,KAAK,SAAL,CAAe,GAAf,CAAb;AACA,WAAO,IAAI,CAAC,QAAL,KAAkB,KAAK,IAA9B;AACA,GAHM;AAKP;;;;;;;;AAMO,EAAA,SAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,GAAlB,EAA6B;AAC5B,QAAM,IAAI,GAAG,KAAK,SAAL,CAAe,GAAf,CAAb;AACA,WAAO,IAAI,CAAC,QAAL,KAAkB,KAAK,IAA9B;AACA,GAHM;;AAIR,SAAA,SAAA;AAAC,CAxJD,EAAA","sourceRoot":"","sourcesContent":["/*\r\n * Copyright 2017-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\r\n * the License. A copy of the License is located at\r\n *\r\n *     http://aws.amazon.com/apache2.0/\r\n *\r\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\r\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\r\n * and limitations under the License.\r\n */\r\nvar __values = (this && this.__values) || function(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n};\r\nvar DoubleLinkedNode = /** @class */ (function () {\r\n    function DoubleLinkedNode(keyVal) {\r\n        this.key = keyVal ? keyVal : '';\r\n        this.prevNode = null;\r\n        this.nextNode = null;\r\n    }\r\n    return DoubleLinkedNode;\r\n}());\r\n/**\r\n * double linked list plus a hash table inside\r\n * each key in the cache stored as a node in the list\r\n * recently visited node will be rotated to the head\r\n * so the Last Recently Visited node will be at the tail\r\n *\r\n * @member head - dummy head of the linked list\r\n * @member tail - dummy tail of the linked list\r\n * @member hashtable - the hashtable which maps cache key to list node\r\n * @member length - length of the list\r\n */\r\nvar CacheList = /** @class */ (function () {\r\n    /**\r\n     * initialization\r\n     */\r\n    function CacheList() {\r\n        this.head = new DoubleLinkedNode();\r\n        this.tail = new DoubleLinkedNode();\r\n        this.hashtable = {};\r\n        this.length = 0;\r\n        this.head.nextNode = this.tail;\r\n        this.tail.prevNode = this.head;\r\n    }\r\n    /**\r\n     * insert node to the head of the list\r\n     *\r\n     * @param node\r\n     */\r\n    CacheList.prototype.insertNodeToHead = function (node) {\r\n        var tmp = this.head.nextNode;\r\n        this.head.nextNode = node;\r\n        node.nextNode = tmp;\r\n        node.prevNode = this.head;\r\n        tmp.prevNode = node;\r\n        this.length = this.length + 1;\r\n    };\r\n    /**\r\n     * remove node\r\n     *\r\n     * @param node\r\n     */\r\n    CacheList.prototype.removeNode = function (node) {\r\n        node.prevNode.nextNode = node.nextNode;\r\n        node.nextNode.prevNode = node.prevNode;\r\n        node.prevNode = null;\r\n        node.nextNode = null;\r\n        this.length = this.length - 1;\r\n    };\r\n    /**\r\n     * @return true if list is empty\r\n     */\r\n    CacheList.prototype.isEmpty = function () {\r\n        return this.length === 0;\r\n    };\r\n    /**\r\n     * refresh node so it is rotated to the head\r\n     *\r\n     * @param key - key of the node\r\n     */\r\n    CacheList.prototype.refresh = function (key) {\r\n        var node = this.hashtable[key];\r\n        this.removeNode(node);\r\n        this.insertNodeToHead(node);\r\n    };\r\n    /**\r\n     * insert new node to the head and add it in the hashtable\r\n     *\r\n     * @param key - the key of the node\r\n     */\r\n    CacheList.prototype.insertItem = function (key) {\r\n        var node = new DoubleLinkedNode(key);\r\n        this.hashtable[key] = node;\r\n        this.insertNodeToHead(node);\r\n    };\r\n    /**\r\n     * @return the LAST Recently Visited key\r\n     */\r\n    CacheList.prototype.getLastItem = function () {\r\n        return this.tail.prevNode.key;\r\n    };\r\n    /**\r\n     * remove the cache key from the list and hashtable\r\n     * @param key - the key of the node\r\n     */\r\n    CacheList.prototype.removeItem = function (key) {\r\n        var removedItem = this.hashtable[key];\r\n        this.removeNode(removedItem);\r\n        delete this.hashtable[key];\r\n    };\r\n    /**\r\n     * @return length of the list\r\n     */\r\n    CacheList.prototype.getSize = function () {\r\n        return this.length;\r\n    };\r\n    /**\r\n     * @return true if the key is in the hashtable\r\n     * @param key\r\n     */\r\n    CacheList.prototype.containsKey = function (key) {\r\n        return key in this.hashtable;\r\n    };\r\n    /**\r\n     * clean up the list and hashtable\r\n     */\r\n    CacheList.prototype.clearList = function () {\r\n        var e_1, _a;\r\n        try {\r\n            for (var _b = __values(Object.keys(this.hashtable)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var key = _c.value;\r\n                if (this.hashtable.hasOwnProperty(key)) {\r\n                    delete this.hashtable[key];\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        this.head.nextNode = this.tail;\r\n        this.tail.prevNode = this.head;\r\n        this.length = 0;\r\n    };\r\n    /**\r\n     * @return all keys in the hashtable\r\n     */\r\n    CacheList.prototype.getKeys = function () {\r\n        return Object.keys(this.hashtable);\r\n    };\r\n    /**\r\n     * mainly for test\r\n     *\r\n     * @param key\r\n     * @return true if key is the head node\r\n     */\r\n    CacheList.prototype.isHeadNode = function (key) {\r\n        var node = this.hashtable[key];\r\n        return node.prevNode === this.head;\r\n    };\r\n    /**\r\n     * mainly for test\r\n     *\r\n     * @param key\r\n     * @return true if key is the tail node\r\n     */\r\n    CacheList.prototype.isTailNode = function (key) {\r\n        var node = this.hashtable[key];\r\n        return node.nextNode === this.tail;\r\n    };\r\n    return CacheList;\r\n}());\r\nexport default CacheList;\r\n//# sourceMappingURL=CacheList.js.map"]},"metadata":{},"sourceType":"module"}